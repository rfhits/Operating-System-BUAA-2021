# 笔记

lab4-1最重要的就是明白系统调用是个什么顺序，以及MIPS函数调用时，参数传递的约定。

首先，我们要能够理解教程中关于系统调用的讲解：

操作系统将自己所能够提供的服务以**系统调用**的方式提供给用户空间。

用户程序即可通过操作系统来完成一些**特殊的操作**。同时，所有的特殊操作就全部在操作系统的掌控之中了（因为用户程序只能通过由操作系统提供的系统调用来完成这些操作，所以操作系统可以确保用户不破坏系统的稳定）。

而直接使用这些系统调用较为麻烦，于是由产生了用户空间的一系列API，如POSIX、C 标准库等，它们在系统调用的基础上，实现更多更高级的常用功能，使得用户在编写程序时不用再处理这些繁琐而复杂的底层操作，而是直接通过调用高层次的API 就能实现各种功能。

## 系统调用和参数传递

首先，有用户和内核之间的区别。用户调用`user/syscall_lib.c`里面的函数，就是`syscall_*(args)`之类的，注意这里叫做sys**call**，在我理解，只是一个call，而不是自己“真正地”执行。

还要明确用户和内核都有自己的**栈**，即内核态执行汇编时，有自己专门的stack_pointer的位置，和用户态下stack_pointer的位置不一样。

在这个过程，我们要知道MIPS参数传递的约定，如下图

![](/img/lab4/args_passing.jpg)

我觉得自己画地挺清楚的，这就是进入一个func函数后，那些参数被存储在了通用寄存器（和栈）里。值得注意的是，因为采用寄存器传参可以提高访问的速度，所以部分参数在寄存器里。

栈底部总是空了四个，我猜想可能是给寄存器留的，说不定哪一天就不采用寄存器传参了，还可以理解为对取出**第几个**参数有好处——

比如进入函数后，sp已经指向了arg0的位置（尽管是空的），我要arg**5**，那么，sp+4\***5**就行。

`syscall_\*()`完了，跳到`user/syscall_wrap.S`，也只是起一个跳转的作用，再接着，就是一个大头，要我们填写的这个`lib/syscall.S`，注意这个汇编有一句`SAVE_ALL`，也就是说，刚刚那个在用户态进入函数的一个**状态**，包括所用通用寄存器的状态和用户态下栈的位置，都被freeze到了新的、内核态下sp的TrapFrame里面了。

如下图：

![](/img/lab4/syscall.jpg)

我们要做的，就是，在这个内核态，复现刚才在用户态下的**状态**——寄存器、栈里面，是按顺序排好的参数。

那么思路就很明了：

1. 将TrapFrame里存储的\$a0~\$a3的内存块取出，放到现在的\$a0~\$a3里面
2. 暂时性存储user_sp，然后取出arg4和arg5，放到现在sys_sp下面对应的位置，
3. 按照寄存器传参约定，为sys_sp上面留好空白
4. 根据本.S最后那个table，跳转到内核函数，sys_\*（注意这时没有“call”，有同学上机挂这了）
5. 返回后，sys_sp回归相应的位置，原来的参数用不着了
6. ...不用我们再填了

弄懂这个，对上机大有好处，我就是在上机前一个晚上弄明白的，感谢我的老班长。
