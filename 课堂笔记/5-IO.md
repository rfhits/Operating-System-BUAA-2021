<!-- START doctoc generated TOC please keep comment here to allow auto update -->

<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [IO](#io)
  - [IO管理概述](#io%E7%AE%A1%E7%90%86%E6%A6%82%E8%BF%B0)
    - [IO设备分类](#io%E8%AE%BE%E5%A4%87%E5%88%86%E7%B1%BB)
    - [设备管理的目标和功能](#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E7%9A%84%E7%9B%AE%E6%A0%87%E5%92%8C%E5%8A%9F%E8%83%BD)
      - [目标](#%E7%9B%AE%E6%A0%87)
      - [功能](#%E5%8A%9F%E8%83%BD)
    - [统一的读写接口](#%E7%BB%9F%E4%B8%80%E7%9A%84%E8%AF%BB%E5%86%99%E6%8E%A5%E5%8F%A3)
  - [IO硬件接基础](#io%E7%A1%AC%E4%BB%B6%E6%8E%A5%E5%9F%BA%E7%A1%80)
    - [设备控制器](#%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8)
    - [CPU和设备控制器之间的交互](#cpu%E5%92%8C%E8%AE%BE%E5%A4%87%E6%8E%A7%E5%88%B6%E5%99%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92)
  - [IO软件原理](#io%E8%BD%AF%E4%BB%B6%E5%8E%9F%E7%90%86)
    - [用户访问IO设备的方式](#%E7%94%A8%E6%88%B7%E8%AE%BF%E9%97%AEio%E8%AE%BE%E5%A4%87%E7%9A%84%E6%96%B9%E5%BC%8F)
      - [I/O功能实现的角度](#io%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0%E7%9A%84%E8%A7%92%E5%BA%A6)
      - [用户进程的角度](#%E7%94%A8%E6%88%B7%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%A7%92%E5%BA%A6)
    - [IO控制技术](#io%E6%8E%A7%E5%88%B6%E6%8A%80%E6%9C%AF)
      - [程序控制I/O(Programmed I/O)](#%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6ioprogrammed-io)
      - [中断驱动方式](#%E4%B8%AD%E6%96%AD%E9%A9%B1%E5%8A%A8%E6%96%B9%E5%BC%8F)
      - [直接存储访问方式(DMA, Direct Memory Access)](#%E7%9B%B4%E6%8E%A5%E5%AD%98%E5%82%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8Fdma-direct-memory-access)
      - [IO通道控制方式](#io%E9%80%9A%E9%81%93%E6%8E%A7%E5%88%B6%E6%96%B9%E5%BC%8F)
  - [IO软件概述](#io%E8%BD%AF%E4%BB%B6%E6%A6%82%E8%BF%B0)
    - [中断处理过程](#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B)
    - [设备驱动程序](#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F)
    - [与设备无关的软件](#%E4%B8%8E%E8%AE%BE%E5%A4%87%E6%97%A0%E5%85%B3%E7%9A%84%E8%BD%AF%E4%BB%B6)
    - [用户空间的IO软件](#%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E7%9A%84io%E8%BD%AF%E4%BB%B6)
  - [设备管理实例](#%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%AE%9E%E4%BE%8B)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# IO

个人认为，重点是，IO控制技术，DMA、缓冲、SPOOLing以及逐层调用的思想。

导致这篇笔记废话很多，大部分不考。

## IO管理概述

计算机连接很多设备，这些设备里就有很多IO设备。

总线（BUS）是接入IO设备的主要方式。

### IO设备分类

> 考过一次硬盘是什么设备

* 传输速度：低速、中速、高速
* 信息交换单位：**块设备**和**字符设备**
  块设备：以块为传输单位的设备，每个块可以独立于其他块进行读写。例如：**硬盘**、CD-ROM、**USB**盘等。
  字符设备：以字符为单位发送或者接收字符流的设备，不可寻址。例如：**打印机**、网卡、**鼠标**等。
* 共享属性：独占设备、共享设备

### 设备管理的目标和功能

#### 目标

1. 方便使用：方便用户使用，**屏蔽外设的差异**，对不同类型的设备**统一使用方法**，协调对设备的并
   发使用
2. 提高效率：提高I/O**访问效率**，匹配CPU和多种不同处理速度的外设
3. 方便控制：方便OS对设备的控制。例如：**增加和删除设备**，适应新的设备类型

#### 功能

1. 提供使用设备的**用户接口**：命令行接口和编程接口。
2. 设备分配和释放：使用设备前，需要分配设备和相应的通道、控制器。
3. 设备的访问和控制：包括并发访问和差错处理
4. I/O缓冲和调度：目标是提高I/O访问效率

### 统一的读写接口

> **设备驱动程序**实现了标准的接口。

当应用程序调用open,read,write等函数时，最终会调用驱动中的fopen,fwrite,fread等函数。其过程如下

1. 当应用程序调用open，read，ioctl等函数(C库)时，会**陷入到系统**。
2. 然后，会进入到**内核系统**调用接口(system call interface)，会调用sys_open,sys_read,sys_write。
3. 然后会进入**虚拟文件系统**(VFS)virtual filesystem。
4. 最后进入到**驱动函数**的open，read，write函数，read函数的本质就是copy_to_user,而write函数就是
   copy_from_user。

用户进程利用在对设备文件进行诸如read/write操作的时候，系统调用通过设备文件的主设备号找到相应的设备驱动程序，然后读取这个**数据结构相应的函数指针**，接着把控制权交给该函数。

## IO硬件接基础

> 有了设备管理的目标，自然就要知道具体怎么管理，包括硬件和软件。

### 设备控制器

CPU和IO设备之间的一个电子设备，相当于多了一层。

控制设备的功能：

1. 一方面通过低层次的接口和硬件通讯
2. 一方面提供高层次的接口和CPU通讯
3. 通过一层抽象，屏蔽了底层硬件接口的复杂度

组成：

1. 控制器与CPU接口：数据寄存器、控制寄存器、状态寄存器
   - 专门的I/O指令
   - 内存映射I/O
2. 控制器与设备接口：数据信号、控制信号、状态信号

### CPU和设备控制器之间的交互

> CPU怎么和硬件去交互

**CPU主要和设备控制器交互**

1. 控制器包括一组可以读写的寄存器
2. 也可能包括可以寻址的内存缓冲

**每个寄存器被分配一个I/O端口号**

* 所有I/O端口构成了IO地址空间

**CPU以访问控制器的方式:**

1. I/O 指令: in/out 指令
   + 独立的IO和内存空间
   + Intel 体系架构: out 0x21,AL
2. 内存映射 I/O: load/store指令 (MIPS)
   - 控制器的内存/寄存器作为物理内存空间的一部分，可以寻址访问
   - 对I/O的操作通过load和store指令来实现

## IO软件原理

### 用户访问IO设备的方式

#### I/O功能实现的角度

阻塞v.s.非阻塞

阻塞：进程对设备发出某种操作（如读/写）后被阻塞

- read():在数据准备好之前，进程进入睡眠状态
- write():设备准备好之前，进程进入睡眠状态

非阻塞：进程对设备发出某种操作后立即返回。

- 当数据或者设备准备好之后，需要一定的机制来通知进程。例如: select()。

#### 用户进程的角度

异步v.s.同步

异步：不等待数据返回。

用户进程发出读数据请求后，立即返回，内核将数据填充到用户的缓冲区(或从缓冲区取走数据)，然后通知用户进程。

* 窗口事件的响应大都是异步的回调函数
* 大量网络数据的发送常常异步

同步：用户进程发出请求之后，一直等待返回结果。

+ 快速的控制命令发送

### IO控制技术

#### 程序控制I/O(Programmed I/O)

> 看起来像是同步的

I/O操作由程序发起并**等待操作完成**。数据的每次读写通过CPU。

轮询或者忙等

- 优点：实现简单
- 缺点：CPU利用率低，在外设进行数据处理时，CPU只能等待．导致CPU资源浪费

#### 中断驱动方式

I/O操作由程序发起，在操作完成时（如数据可读或已经写入)，由外设向CPU发出中断，通知该程序。数据的每次读写通过CPU。

进程请求IO后，CPU调度其他进程，然后每次都要检查是不是IO完成。

![](/img/课堂笔记/5-IO/中断驱动方式的处理过程.jpg)

优点：在**外设进行数据处理**时，CPU不必等待，可以继续执行该程序或其他程序，提高了CPU利用率；可以处理不确定事件。
缺点：每次输入/输出数据都要中断CPU，多次中断浪费CPU时间，只适于数据传输率较低的设备。

#### 直接存储访问方式(DMA, Direct Memory Access)

> 为什么叫做Direct Memory？因为DMA控制器直接把数据送到内存里了，而不用CPU帮着送。

处理过程：

1. 由程序设置DMA控制器中的若干寄存器值（如内存始址，传送字节数），然后发起I/O操作；
2. DMA控制器完成内存与外设的成批数据交换；
3. 在操作完成时由DMA控制器向CPU发出中断。

![](/img/课堂笔记/5-IO/DMA.jpg)

优点：CPU只需干预I/O操作的开始和结束，而**后续成批的数据读写则无需CPU控制**，适于**高速设备**。

缺点:

- 数据传送的方向、存放数据的内存地址及传送数据的长度等都由CPU控制，占用了CPU时间。
- 每个设备占用一个DMA控制器，当设备增加时，需要增加新的DMA控制器。

![](/img/课堂笔记/5-IO/中断驱动和DMA的异同.jpg)

可以看到，进程都发起了request，不过DMA会直接把数据搬运到内存里，而中断仍然需要CPU和寄存器交互。也就是说，中断驱动的视角下，内存和外设之间的关系被撕裂了。

#### IO通道控制方式

> 没考过

I/O通道是专门负责输入输出的**处理器**，独立于CPU，有**自己的指令体系**。可执行由通道指令组成的通道程序，因此可以进行较为复杂的I/O控制。通道程序通常由操作系统所构造，放在内存里。

优点：执行一个通道程序可以完成几组I/O操作，与DMA相比，减少了CPU千预。
缺点：费用较高。

> 通道种类：
>
> + 字节多路通道
>   - 以字节为单位分时交叉工作:当为一台设备传送一个字节后，立即转去为另一它设备传送一个字节
>   - 适用于连接打印机、终端等低速或中速的I/O设备。
>
> - 数组选择通道
>   - 以“组方式”工作，每次传送一批数据，传送速率很高，但在一段时间只能为一台设备服务。每当一个I/O请求处理完之后，就选择另一台设备并为其服务;
>   - 适用于连接磁盘、磁带等高速设备。
> - 数组多路通道
>   - 综合了字节多路通道分时工作和选择通道传输速率高的特点
>   - 其实质是:对通道程序采用多道程序设计技术，使得与通道连接的设备可以并行工作。

I/O通道与DMA的区别

+ DMA方式下，数据的传送方向、存放数据的内存起始地址和数据块长度都由CPU控制。而通道是一个特殊的处理器，有自己的指令和程序，通过**执行通道程序**实现对数据传输的控制，所以通道具有更强的独立处理I/O的功能。
+ DMA控制器通常只能控制一台或者少数几台同类设备，而一个通道可同时控制多种设备。

## IO软件概述

### 中断处理过程

1. 关中断
2. 保存现场（各种寄存器和PSW)
3. 为中断处理程序设置上下文(TLB，MMU，页表)和堆栈
4. 运行设备中断处理程序，进行中断处理·恢复被中断进程的现场
5. 开中断
6. 设置MMU，PSW以执行下一个进程

中断处理需要花费相当多的CPU周期

### 设备驱动程序

略

### 与设备无关的软件

1. 驱动统一接口
2. 缓冲技术
   + 单缓冲，CPU和外设轮流使用
   + 双缓冲，CPU和外设连续使用
   + 环形缓冲
   + 缓冲池
3. 错误报告
4. 设备分配

### 用户空间的IO软件

着重介绍SPOOLing(SPOOLing,Simultaneous PeripheralOperation On Line)，也称为虚拟设备技术。

利用**假脱机技术**（SPOOLing）可把**独享设备**转变成具有**共享特征**的虚拟设备，从而提高设备利用率。

在多道程序系统中，专门利用一道程序(SPOOLing程序，一个daemon守护进程)来完成对设备的I/O操作。

SPOOLing程序和外设进行数据交换：实际I/O，SPOOLing程序预先从外设读取数据并加以缓冲，在以后需要的时候输入到应用程序;

应用程序进行I/O操作时，只是**和SPOOLing程序**交换数据，可以称为“虚拟I/O”。应用程序实际上是从SPOOLing程序的缓冲池中读出数据或把数据送入缓冲池，而不是跟实际的外设进行I/O操作。

特点：

+ 高速虚拟I/O操作：应用程序的虚拟I/O比实际I/O速度提高,缩短应用程序的执行时间（尽快完成计算，并释放占用的计算机资源)。另一方面，程序的虚拟I/O操作时间和实际I/O操作时间分离开来。
+ 实现对独享设备的共享：由SPOOLing程序提供虚拟设备，可以对独享设备依次共享使用。

## 设备管理实例

略。我讲个der
