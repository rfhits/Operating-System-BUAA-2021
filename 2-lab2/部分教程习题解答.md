# 部分教程习题解答


Exercise 2.3
完成 page_init 函数，使用 include/queue.h 中定义的宏函数将未分配的物理页加入到空闲链表 page_free_list 中去。思考如何区分已分配的内存块和未分配的内存块，并注意内核可用的物理内存上限。提示：

1. 首先，需要使用定义在include/queue.h 中的宏函数LIST_INIT 去初始化空闲页面链表page_free_list（这个链表的意义在前文已经提及，如有遗忘可以往回查阅）。
2. 在mm/pmap.c 中，我们定义了一个u_long（非负长整数）变量freemem，这个变量是在没有建立起基于物理页面的物理内存管理机制前用于物理内存的分配，用于记录已经分配了多少物理内存出去、下一次分配应该从哪里开始继续分配。
   在我们完整的MOS 进行内存管理初始化的时候，在page_init 函数被调用前，freemem 会被别的函数修改，比如定义在mm/pmap.c 中的函数static void alloc（这个函数我们已经为大家实现了，但仍然希望大家阅读代码并看看哪些函数调用了alloc），这也就意味着在page_init 中我们所遇到的freemem 不一定是按照BY2PG（宏常量，代表一个页面有多少个字节，定义于include/mmu.h）对齐的。但是，在page_init 中我们需要将剩余的空闲物理内存按照页面为单位管理起来，这也就要求我们将freemem 按照BY2PG 进行对齐。考虑到我们先前分配物理内存是从低地址到高地址分配，所以我们需要将freemem 以BY2PG 为单位，向上取整，我们为大家提供了实现该功能的宏函数ROUND（定义于include/types.h）。
3. 通过向上取整，我们此时可以认为freemem 以下的物理页面是已经被使用了的，需要对其对应的Page 结构体进行修改。值得注意的是这里通过freemem计算已经有多少个物理页面被使用了不能直接拿freemem 除以BY2PG，需要写成PADDR(freemem) 除以BY2PG，其原理此处暂不解释，待学完虚拟内存管理，想必就可以理解此操作的含义了。**
