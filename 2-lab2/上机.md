<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [lab2上机](#lab2%E4%B8%8A%E6%9C%BA)
  - [lab2-1](#lab2-1)
    - [exam](#exam)
      - [题目背景](#%E9%A2%98%E7%9B%AE%E8%83%8C%E6%99%AF)
      - [任务1](#%E4%BB%BB%E5%8A%A11)
      - [任务2](#%E4%BB%BB%E5%8A%A12)
      - [任务3](#%E4%BB%BB%E5%8A%A13)
    - [Extra](#extra)
      - [题目背景](#%E9%A2%98%E7%9B%AE%E8%83%8C%E6%99%AF-1)
      - [任务一](#%E4%BB%BB%E5%8A%A1%E4%B8%80)
      - [任务二](#%E4%BB%BB%E5%8A%A1%E4%BA%8C)
      - [任务三](#%E4%BB%BB%E5%8A%A1%E4%B8%89)
  - [lab2-2](#lab2-2)
    - [exam](#exam-1)
      - [任务0](#%E4%BB%BB%E5%8A%A10)
      - [任务1](#%E4%BB%BB%E5%8A%A11-1)
      - [任务2](#%E4%BB%BB%E5%8A%A12-1)
      - [任务3](#%E4%BB%BB%E5%8A%A13-1)
      - [解答](#%E8%A7%A3%E7%AD%94)
    - [Extra](#extra-1)
      - [要求](#%E8%A6%81%E6%B1%82)
      - [注意](#%E6%B3%A8%E6%84%8F)
      - [提示](#%E6%8F%90%E7%A4%BA)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# lab2上机

## lab2-1

### exam

#### 题目背景

我们实现的MOS操作系统中，所有的物理页的可能状态有三种：使用中物理页、空闲物理页、已经被申请但未被使用的物理页。

Note：page_alloc的时候只是申请了一个物理页，但是物理页没有使用，请仔细思考这三种状态物理页的判定方法。

说明：

1. 使用中的物理页：当前使用次数不为0的物理页，状态标记为1
2. 已经被申请但未使用的物理页：当前使用次数为0，但是已经被申请出去的物理页，状态标记为2
3. 空闲物理页：当前可以被申请的物理页，状态标记为3

#### 任务1

在pmap.c中实现函数`int page_alloc2(struct Page **pp)`，并在pmap.h中添加该函数的声明。其功能与原有的page_alloc完全一样（你可以直接复制page_alloc的代码）,唯一的区别在于，如果确实分配到了物理页面，该函数要输出分配到的物理页的信息

输出格式： `printf("page number is %x, start from pa %x\n",ppn,pa);`

其中ppn为页号，pa为该页面的起始物理地址

#### 任务2

在pmap.c中实现函数 `void get_page_status(int pa)` 并在pmap.h中添加该函数的声明。函数输入的是一个物理地址，请按格式输出该物理页的状态信息。

输出格式： `printf("times:%d, page status:%d\n",var1,var2);`

其中var1是统计该函数被调用的次数（首次从1开始），var2是返回该物理地址对应的页面状态标记数字。
评测要求：请确保page_init初始化后page_free_list从表头到表尾物理页下标依次递减

#### 任务3

本次课上测试会对课下测试进行加强测试，请大家在pmap.h中添加以下函数定义（请不要在pmap.c中添加这两个函数的实现，否则远端测评无法编译）：

1. `void test_queue();`
2. `void pm_check();`

### Extra

#### 题目背景

常见的管理空闲内存的方法有两种：链表管理法与位图管理法。在lab2中，我们通过链表实现了对空闲内存的管理，下面的extra部分将要求大家实现用位图管理空闲内存。

用位图管理内存需要给每个分配单元赋予一个二进制数位，用来记录该分配单元是否闲置。

位图规格要求：

数位取值为0表示单元闲置，取值为1则表示已被占用。

用一个unsigned int page_bitmap数组管理内存，要求在该数组中，标号小的元素的低位表示页号小的页面。例如，0号页面由page_bitmap[0]的第0位表示，63号页面由page_bitmap[1]的第31位表示。当只有0号页面与63号页面被占用时，应该有：page_bitmap[0]=0x00000001, page_bitmap[1]=0x80000000

题目要求：

#### 任务一

在pmap.c中添加如下的空闲页面位图定义：

unsigned int page_bitmap[NUM];

其中NUM是一个你需要计算的数，要求这个数组可以恰好表示所有物理页面，不多不少

修改page_init(),除需要初始化位图外，需要添加输出：

printf("page bitmap size is %x\n", NUM);，

其中NUM为page_bitmap数组的元素个数

#### 任务二

修改page_alloc(struct Page **pp)，要求分配到的页面是空闲页面中页号最小的

#### 任务三

修改page_free(struct Page *pp)

三个函数修改后需要满足前述的位图规格要求。除页面组织形式外，其他要求与课下要求相同。

注意：请保证没有使用链表相关操作组织页面，评测时若发现使用链表组织页面将不予通过！

评测要求：为了正确评测，请在pmap.h中添加以下函数定义（请不要在pmap.c中添加这个函数的实现，否则远端测评无法编译）：
`void pm_check(void);`

## lab2-2

### exam

在自映射的条件下，请实现函数完成下列任务：

#### 任务0

64位操作系统采用三级页表进行虚拟内存管理，每个页表大小为4KB，页表项需要字对齐，其
余条件与二级页表管理32位操作系统相同。请问64位中最少用多少位表示虚拟地址。

#### 任务1

输入二级页表的起始虚拟地址va，返回一级页表的起始虚拟地址。

#### 任务2

输入页目录的虚拟地址va和一个整数n，返回页目录第n项所对应的二级页表的起始虚拟地址。

**上面的任务1与2，是让你熟悉自映射的有关知识，所有的地址都只是一个u_long类型的数字，并没有
和操作系统打交道，那么最后一个任务则要求你真正填写页表。**

#### 任务3

给定一个一级页表的指针pgdir和二级页表起始虚拟地址va，va为内核态虚拟地址。把合适的地址填写到pgdir的指定位置，使得pgdir能够完成正确的自映射。（即计算出va对应的物理地址所在一级页表项位置，并在那里填入正确的页号和权限位）

输入输出约定：

在include/pmap.h中声明，同时在mm/pmap.c中编写函数：

`u_long cal_page(int func, u_long va, int n, Pde *pgdir);`

**输入：**

func为0，1，2，3分别对应前面的任务0123。

1. va为前述任务中的虚拟地址，func为0时，传入0。
2. n仅在第二项任务中有意义，意义同题目叙述。在func为0，1，3时，传入0。
3. pgdir仅在第三项任务中有意义，意义同题目叙述。在func为0，1，2时，传入0。

**输出：**

任务0要求返回正确答案，任务1，2 返回要求地址，任务3返回0即可。

#### 解答

这次测评非常坑，必须要把任务0做出来，否则测评机会反馈整个exam零分。而这一点是离结束40分内才说的，有的教室甚至没说，所以有的放弃任务0而去de其他任务的bug的同学（别骂了），血亏。

任务0答案是39，一个页表4KB，64位机中，一个entry大小为64b=8B，一个页表中有$=2^9$项，三级页表，$total\_bit=3\times 9 + pgshift=3\times 9 + 12 = 39$。

### Extra

请实现满足下列要求的函数：

给定一个页目录的起始地址，统计在相应的页表中使用物理页面的情况，其中需要对传入的cnt数组进行修改，使cnt[i]表示第i号物理页被页目录下的虚拟页映射的**总次数**。

#### 要求

1. 在pmap.c文件中编写函数 int count_page(Pde *pgdir, int *cnt)
2. 在pmap.h文件中进行函数声明 int count_page(Pde *pgdir, int *cnt);

函数输入的Pde指针的值为页目录的内核虚拟地址，cnt为数组首地址，函数的返回值为cnt数组的元素个
数，即物理页的数量（在我们的操作系统中，这个的值为一个常量），cnt[i]表示页目录下有cnt[i]个虚拟
页映射到了第i号物理页。

#### 注意

1. 如果想本地测试的话可以在init.c中进行测试，提交时会进行替换。
2. 自己写的其他测试辅助函数不要有standard单词，防止和评测冲突导致编译错误。

#### 提示

1. 物理页的使用情况包括页目录、二级页表及所有被映射到的物理页。
2. 一个物理页可能被进程的多个虚拟页映射。
3. 传入的cnt数组不一定全0。
