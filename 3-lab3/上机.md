<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**  *generated with [DocToc](https://github.com/thlorenz/doctoc)*

- [lab3ä¸Šæœº](#lab3%E4%B8%8A%E6%9C%BA)
  - [lab3-1](#lab3-1)
    - [exam](#exam)
      - [PART1](#part1)
      - [PART2](#part2)
      - [PART3](#part3)
      - [è§£ç­”](#%E8%A7%A3%E7%AD%94)
    - [Extra](#extra)
      - [é¢˜ç›®](#%E9%A2%98%E7%9B%AE)
      - [è§£ç­”](#%E8%A7%A3%E7%AD%94-1)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# lab3ä¸Šæœº

## lab3-1

### exam

#### PART1

åœ¨ä»Šå¤©çš„å®žéªŒé‡Œæˆ‘ä»¬è¦æ±‚ä½ å®žçŽ°ä¸€ä¸ªç®€æ˜“çš„ fork å‡½æ•°ï¼ˆå¹¶ä¸åŒ…æ‹¬å®žé™…loadä»£ç æ®µï¼‰ï¼Œé€šè¿‡ç»™å®šçš„åŽŸå§‹è¿›ç¨‹å—(è¾“å…¥å‚æ•°struct Env *e)ç”Ÿæˆä¸€ä¸ªæ–°çš„è¿›ç¨‹æŽ§åˆ¶å—ï¼Œå¹¶è¿”å›žæ–°è¿›ç¨‹æŽ§åˆ¶å—çš„env_idã€‚åŒå­¦ä»¬éœ€è¦åœ¨ lib/env.c å’Œ include/env.h ä¸­åˆ†åˆ«å®šä¹‰å’Œå£°æ˜Ž fork å‡½æ•°ï¼Œå‡½æ•°æŽ¥å£å¦‚ä¸‹ï¼š
u_int fork(struct Env *e);
è¦æ±‚å¦‚ä¸‹ï¼š

1. ä»Ž env_free_list ä¸­ä»Žå¤´ç”³è¯·ä¸€ä¸ªæ–°çš„è¿›ç¨‹æŽ§åˆ¶å—
2. æ–°è¿›ç¨‹æŽ§åˆ¶å—çš„ env_statusã€env_pgdirã€env_cr3ã€env_priå’ŒåŽŸè¿›ç¨‹æŽ§åˆ¶å—ä¿æŒä¸€è‡´ã€‚
3. ä¸ºæ–°è¿›ç¨‹æŽ§åˆ¶å—ç”Ÿæˆå¯¹åº”çš„ env_id
4. env_parent_id çš„å€¼ä¸ºåŽŸè¿›ç¨‹æŽ§åˆ¶å—çš„ env_id
5. è¿”å›žå€¼ä¸ºæ–°è¿›ç¨‹çš„env_id

#### PART2

void lab3_output(u_int env_id);

æœ¬éƒ¨åˆ†è¦æ±‚ä¿®æ”¹struct Envï¼Œåœ¨è¿›ç¨‹æŽ§åˆ¶å—ä¸­å¢žåŠ å­—æ®µï¼ˆå…·ä½“å¢žåŠ å“ªäº›å†…å®¹è¯·è‡ªè¡Œç»„ç»‡ï¼‰ç»„ç»‡èµ·è¿›ç¨‹é—´çš„çˆ¶å­ã€å…„å¼Ÿå…³ç³»ï¼Œå¹¶æŒ‰ç…§è¦æ±‚åœ¨ lib/env.c å’Œ include/env.h ä¸­åˆ†åˆ«å®šä¹‰å’Œå£°æ˜Ž lab3_output å‡½æ•°è¾“å‡ºç›¸å…³å†…å®¹ï¼Œè¯¦æƒ…å¦‚ä¸‹ï¼š
å‡½æ•°lab3_outputçš„å®šä¹‰å¦‚ä¸‹ï¼š
`void lab3_output(u_int env_id);`
è¦æ±‚è¾“å‡ºçš„å†…å®¹æœ‰å…¶çˆ¶è¿›ç¨‹çš„env_idã€å…¶ç¬¬ä¸€ä¸ªå­è¿›ç¨‹çš„env_idã€å…¶å‰ä¸€ä¸ªå…„å¼Ÿè¿›ç¨‹çš„env_idä»¥åŠå…¶åŽä¸€ä¸ªå…„å¼Ÿè¿›ç¨‹çš„env_id
æ‰€æœ‰çš„å­è¿›ç¨‹éƒ½ç”±forkåˆ›å»ºï¼Œä¸¤ä¸ªè¿›ç¨‹å¦‚æžœæ˜¯å…„å¼Ÿï¼Œå®ƒä»¬çš„çˆ¶è¿›ç¨‹ä¸€å®šç›¸åŒã€‚
ä»¥æŸè¿›ç¨‹ç¬¬ä¸€ä¸ªå­è¿›ç¨‹æ˜¯æŒ‡ï¼Œç”±è¯¥è¿›ç¨‹ä½œä¸ºçˆ¶è¿›ç¨‹ä½¿ç”¨forkåˆ›å»ºçš„ç¬¬ä¸€ä¸ªå­è¿›ç¨‹ã€‚
å…„å¼Ÿè¿›ç¨‹é—´çš„é¡ºåºå³ä¸ºè¿™äº›è¿›ç¨‹è¢«åˆ›å»ºçš„é¡ºåºï¼Œå‰ä¸€ä¸ªå…„å¼Ÿè¿›ç¨‹ä¸ºè¾ƒæ—©è¢«åˆ›å»ºçš„è¿›ç¨‹
éœ€è¦åœ¨PART1çš„forkå‡½æ•°ä¸­è¿›è¡Œå¯¹æ·»åŠ å­—æ®µçš„ä¿®æ”¹
è¾“å‡ºæ ¼å¼ä¸ºï¼šprintf("%08x %08x %08x %08x\n", a, b, c, d);
å…¶ä¸­a, b, c, dåˆ†åˆ«ä¸ºçˆ¶è¿›ç¨‹çš„env_idã€ç¬¬ä¸€ä¸ªå­è¿›ç¨‹çš„env_idã€å‰ä¸€ä¸ªå…„å¼Ÿè¿›ç¨‹çš„env_idä»¥åŠåŽä¸€ä¸ªå…„å¼Ÿè¿›ç¨‹çš„env_id
å¦‚æžœa, b, c, dä¸­æœ‰ä¸å­˜åœ¨çš„å‚æ•°ï¼Œåˆ™è¾“å‡º0

#### PART3

åœ¨PART2çš„åŸºç¡€ä¸Šï¼Œåœ¨ lib/env.c å’Œ include/env.h ä¸­åˆ†åˆ«å®šä¹‰å’Œå£°æ˜Ž lab3_get_sum å‡½æ•°ï¼Œå‡½æ•°çš„åŠŸèƒ½ä¸ºï¼šç»™å®šä¸€ä¸ªè¿›ç¨‹çš„env_idï¼Œè¿”å›žä»¥è¯¥è¿›ç¨‹ä¸ºæ ¹èŠ‚ç‚¹çš„å­è¿›ç¨‹æ ‘ä¸­è¿›ç¨‹çš„æ•°ç›®ï¼ˆåŒ…æ‹¬å®ƒæœ¬èº«ï¼‰ï¼Œå…·ä½“æŽ¥å£å¦‚ä¸‹ï¼š
int lab3_get_sum(u_int env_id);

#### è§£ç­”

æ¯”è¾ƒç®€å•ï¼Œä½†æ˜¯å°å‘ä¸æ–­ã€‚æœ‰çš„äººç¬¬ä¸€é¢˜æ²¡æœ‰ç”¨`env_alloc()`ç»“æžœå¿˜è®°ç»™`free_env_list`removeæŽ‰åˆ†é…çš„`env`

æ–—èƒ†æ”¾ä¸Šè‡ªå·±çš„ä»£ç ã€‚

é¦–å…ˆæ˜¯ä¿®æ”¹envç»“æž„ä½“ï¼Œè¿™æ¬¡examç”¨æ•°ç»„å†™èµ·æ¥æ¯”è¾ƒç®€å•ã€‚ä¸ºä»€ä¹ˆæˆ‘æ²¡ç”¨é“¾è¡¨å‘¢ï¼Œå› ä¸ºCè¯­è¨€åŠŸåº•å¤ªå·®ï¼Œï¼Œç”¨æŒ‡é’ˆæ€•é”™ã€‚ã€‚ã€‚


```cpp
struct Env {
        struct Trapframe env_tf;        // Saved registers
        LIST_ENTRY(Env) env_link;       // Free list
        u_int env_id;                   // Unique environment identifier
        u_int env_parent_id;            // env_id of this env's parent
        u_int env_status;               // Status of the environment
        Pde  *env_pgdir;                // Kernel virtual address of page dir
        u_int env_cr3;
        LIST_ENTRY(Env) env_sched_link;
        u_int env_pri;
        // Lab 4 IPC
        u_int env_ipc_value;            // data value sent to us
        u_int env_ipc_from;             // envid of the sender
        u_int env_ipc_recving;          // env is blocked receiving
        u_int env_ipc_dstva;            // va at which to map received page
        u_int env_ipc_perm;             // perm of page mapping received

        // Lab 4 fault handling
        u_int env_pgfault_handler;      // page fault state
        u_int env_xstacktop;            // top of exception stack

        // Lab 6 scheduler counts
        u_int env_runs;                 // number of times been env_run'ed
        u_int env_nop;                  // align to avoid mul instruction

        int son_num;            // add on exam
        u_int son_id_arr[1024]; // add on exam

};
```

```cpp
u_int fork(struct Env *e)
{
        struct Env *e_son;
        env_alloc(&e_son, e->env_id);
        e_son->env_status = e->env_status;
        e_son->env_pgdir = e->env_pgdir;
        e_son->env_cr3 = e->env_cr3;
        e_son->env_pri = e->env_pri;

        // ---- father ----
        int son_num = e->son_num;
        e->son_id_arr[son_num] = e_son->env_id;
        e->son_num += 1;

        return e_son->env_id;
}
```

```cpp

void lab3_output(u_int env_id)
{
        struct Env *e_now;
        u_int fa_id = 0;
        u_int first_son_id = 0;
        u_int bro_bf_id = 0; // "bf" means "before"
        u_int bro_af_id = 0; // "af" means "after"

        envid2env(env_id, &e_now, 0);
        // son part
        first_son_id = e_now->son_id_arr[0];

        // parent part
        fa_id = e_now->env_parent_id;
        if (fa_id == 0) { // do not have parent
                // three 0 now
                bro_bf_id = 0;
                bro_af_id = 0;
        } else { // have a parent
                struct Env *e_fa;
                envid2env(fa_id, &e_fa, 0);
                int index = 0;
                for (index = 0; index < 1024; index++) {
                        if (e_fa->son_id_arr[index] == env_id) {
                                break;
                        } else {
                                continue;
                        }
                }
                // index is the env of father now
                if (index > 0) { // have bro bf
                        bro_bf_id = e_fa->son_id_arr[index - 1];
                }

                // have a bro_af
                if (e_fa->son_num > index + 1) {
                        bro_af_id = e_fa->son_id_arr[index + 1];
                }
        }
        // fa_id, fist_son_id, bro_bf, bro_af
        printf("%08x %08x %08x %08x\n", fa_id, first_son_id, bro_bf_id, bro_af_id);
}
```


```cpp
int lab3_get_sum(u_int env_id)
{
        struct Env *e_now;
        envid2env(env_id, &e_now, 0);
        int son_num = e_now->son_num;
        // if e_now has no son
        if (son_num == 0) {
                return 1;
        } else {
                // have many sons, recuring
                int ans = 1;
                int i = 0;
                for (i = 0; i < son_num; i++) {
                        struct Env *e_son;
                        u_int son_id = e_now->son_id_arr[i];
                        envid2env(son_id, &e_son, 0); // now got a son
                        ans += lab3_get_sum(son_id);
                }
                return ans;
        }
}

```

### Extra

#### é¢˜ç›®

b/env.c å’Œ include/env.h ä¸­åˆ†åˆ«å®šä¹‰å’Œå£°æ˜Ž lab3_kill å‡½æ•°ï¼ŒåŠŸèƒ½ä¸ºï¼šæ€æ­»ä¸€ä¸ªè¿›ç¨‹ã€‚è¿›ç¨‹æ ‘çš„æ ¹èŠ‚ç‚¹ä»£è¡¨çš„è¿›ç¨‹æ”¶å…»ï¼ˆæŽ¥ç®¡ï¼‰ä»–çš„å­¤å„¿è¿›ç¨‹ã€‚è¿™äº›å­¤å„¿è¿›ç¨‹å°†ä¾æ¬¡æŽ’åˆ—åœ¨æ ¹è¿›ç¨‹çš„å­è¿›ç¨‹çš„å°¾éƒ¨ã€‚æµ‹è¯•ä¸­ä¿è¯ä¸ä¼šæ€æ­»æ ¹èŠ‚ç‚¹ä»£è¡¨çš„è¿›ç¨‹ã€‚å‡½æ•°æŽ¥å£å¦‚ä¸‹ï¼š
`void lab3_kill(u_int env_id);`
åœ¨å®Œæˆä¸€æ¬¡åˆ é™¤åŽï¼ŒåŸºç¡€æµ‹è¯•PART2 lab3_outputï¼Œè¾“å‡ºçš„ç»“æžœåœ¨æ–°çš„æ ‘ç»“æž„ä¸‹ä»åº”æ­£ç¡®ã€‚
ä¸€é¢—è¿›ç¨‹æ ‘çš„æ ¹èŠ‚ç‚¹ä»£è¡¨çš„è¿›ç¨‹ç”±env_allocåˆ›å»ºï¼Œå…¶ä½™èŠ‚ç‚¹ä»£è¡¨çš„è¿›ç¨‹çš†ç”±PART1 forkåˆ›å»ºã€‚
æœ¬éƒ¨åˆ†ä¸­â€œæ€æ­»è¿›ç¨‹â€çš„è¦**æ¸…ç©ºè¿›ç¨‹æŽ§åˆ¶å—ç›¸å…³å­—æ®µ**ï¼ˆå¯ä»¥å‚è€ƒ`free_env()`ï¼Œä½†æ˜¯ä¸èƒ½è°ƒç”¨`free_env()`ï¼‰ä»¥åŠå…¶ä»–ç›¸å…³å¤„éƒ¨åˆ†æµ‹è¯•è¾ƒå¼ºï¼Œè¯·åŠ¡å¿…è€ƒè™‘å®Œå–„ã€‚

#### è§£ç­”

ä¸€å †äººä»¥ä¸ºè‡ªå·±çš„æ•°æ®ç»“æž„å‡ºé—®é¢˜äº†ï¼Œç»“æžœï¼Œï¼Œæ˜¯åœ¨æ€æ­»ä¸€ä¸ªè¿›ç¨‹åŽçš„çŠ¶æ€å¤„ç†ä¸Šå‡ºé—®é¢˜äº†ã€‚

æˆ‘ä¸€pushï¼Œå¾—11åˆ†ï¼Œå‘µå‘µï¼Œä¹Ÿè·‘åŽ»deè‡ªå·±ç»“æž„çš„bugäº†ï¼Œä¸è¿‡å·²ç»æ²¡æ—¶é—´äº†ã€‚

æ—©çŸ¥é“examæ‹¿60åˆ†å°±è·‘è·¯äº†ï¼ŒçŽ°åœ¨å‘çŽ°åŽŸæ¥exam60å’Œ100æœ€ç»ˆå¾—åˆ†æ²¡å·®ã€‚éº»äº†ï¼Œæˆ˜æœ¯å¤±è¯¯ã€‚

![](/img/åˆ†å€¼å®‰æŽ’åŠè€ƒæ ¸æ—¶é—´.JPG)

çœ‹äº†å¤§ä½¬çš„[åšå®¢](https://roife.github.io/2021/04/20/buaa-os-lab-lab3-1-process/)ï¼Œå‘çŽ°è‡ªå·±å¯èƒ½æ˜¯æ²¡æœ‰freeåŽæ’å›žlisté‡Œï¼Œæˆ‘å‘µå‘µäº†ðŸ˜‡ã€‚

```cpp
void lab3_kill(u_int env_id)
{
        // get e_now and e_root
        struct Env *e_now;
        struct Env *e_root;
        envid2env(env_id, &e_now, 0);

        u_int root_id = e_now->env_parent_id;
        envid2env(root_id, &e_root, 0);

        // while this "root" have a father
        while (e_root->env_parent_id != 0) {
                root_id = e_root->env_parent_id;
                envid2env(root_id, &e_root, 0);
        }

        // now we get the root
        int now_son_num = e_now->son_num;
        int root_son_num = e_root->son_num;

        int i = 0;

        // remove from father, careful!: root == father
        struct Env *e_fa;
        u_int fa_id = e_now->env_parent_id;
        envid2env(fa_id, &e_fa, 0);
        // get the index
        for (i = 0; i < e_fa->son_num; i++) {
                if (e_fa->son_id_arr[i] == env_id) {
                        break;
                } else {
                        continue;
                }
        }

        // cover
        for (; i < e_fa->son_num-1; i++) {
                e_fa->son_id_arr[i] = e_fa->son_id_arr[i+1];
        }
        e_fa->son_id_arr[i] = 0;
        e_fa->son_num--;


        // attach all sons to root
        for (i = 0; i < now_son_num; i++) {
                u_int now_son_id = e_now->son_id_arr[i];
                e_root->son_id_arr[e_root->son_num] = now_son_id;
                e_root->son_num += 1;
        }

        // free the env
        e_now->son_num = 0;
        for (i = 0; i < e_now->son_num; i++) {
                e_now->son_id_arr[i] = 0;
        }
        e_now->env_status = ENV_FREE;
        e_now->env_cr3 = 0;
        e_now->env_pgdir = 0;

        // maybe i should add, then i can pass
        LIST_INSERT_HEAD(&env_free_list, e, env_link);

}
```
