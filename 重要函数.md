# OS个人思考

> 每当我觉得自己学懂了
> 习题、练习和思考都在告诉我
> “不，你没有”

author: rfhits

## bzero bcopy

真正滴涉及到底层的两个函数。清空一个页、写一个页，都要用到ta li

## Mips

CLI：让CPU禁止相应中断

SAVE_ALL：根据cause寄存器的不同，使得sp不同，然后保留环境，就是各种通用寄存器和CP0。这个宏在stackframe.h里面

`TIMESTACK`是产生时钟中断异常时用的栈指针；`KERNEL_SP`是非时钟中断异常用的栈指针，如系统调用。

## pmap

### 二级页表

首先，c语言可以操作任何空间的地址，这个就是虚拟地址。

我们要做的就是模拟二级页表机制，往虚拟地址里面填写物理地址，再通过$f(va)->pa$和$f(pa)->va$转换取到地址里面的东西。

简单来说，把放着很多很多页的虚拟地址，按照虚拟地址的索引，把它对应的物理地址放到另一个虚拟地址pgidr里。

这样就“假装”建立起了二级页表，物理地址从未使用过，要访问时永远要加上ULIM。

`Page`结构体其实是物理地址的一个“象征”。因为它减去pages拿到ppn以后，shift12位再加上ULIM，就是虚拟地址，减去ULM又变回物理地址。建立起来虚拟页和物理页之间的桥梁。尽管自己不是真正的4KB页，但是是桥梁。

### page_alloc(struct Page \*\*pp)

给一个Page结构体的指针，从`free_page_list`里面分一个，然后用bzero把其对应的物理页里头内容清零。

### page_insert(vars)

我也不知道为什么要起这么个名字。给个\*pp和va，试图用pgdir建立二者之间的联系。

这个函数的简介就是说`mapping`了。

## env

### env_alloc

从`free_env_list`中申请一个`env`，为其`setup_vm`，就是`alloc`一个`page`，把page虚拟地址付给`env`的一个成员变量，把`boot_pgdir`里面的内容给这个`env`拷贝一份。

然后就fill`env`的各个成员变量。

### load_icode_mapper

### Trapfram


| Reg | Num |
| --- | --- |
| k0  | 26  |
| k1  | 27  |
| gp  | 28  |
| sp  | 29  |
| fp  | 30  |
| ra  | 31  |


| Reg    | Num |
| ------ | --- |
| vaddr  | 8   |
| status | 12  |
| cause  | 13  |
| epc    | 14  |


### creat_env_pri

主要讲一下这个进程怎么跑起来的

`init.c`里面先设置好了中断和异常的处理程序。然后去设置时钟，即调用`set_timer()`，`set_timer()`在`kclock_asm.S`里面。`set_timer()`汇编的结尾，应该是更改了cp0，出发了中断。根据指导书所言，会用`handle_int()`去处理这个中断。`handle_int()`在`genex.S`的第50行左右，在结尾调用了`timer_irq`。`timer_irq`就在`handle_int()`汇编的下面，第一行就是调用`sched_yield`。

终于到了调度。从list里挑一个进行`env_run()`，然后在`env_run()`的结尾，用了`pop_tf`，这个函数在`env_asm.S`里。这段汇编把pc设置成了k1里头的地址，相当于j k1，成功跳转到了elf里头的代码。

`set_timer()[kclock_asm.S]->handle_int()[genex.S]->timer_irq()[genex.S]->sched_yield()[sched_yield.c]->env_run()[env.c]->env_pop_tf()[env_asm.S]`

大概是五连跳，一会汇编一会C，呵呵。

### destroy_env()
